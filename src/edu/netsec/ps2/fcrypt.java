package edu.netsec.ps2;

import java.io.*;
import java.math.BigInteger;

import javax.crypto.*;
import javax.crypto.spec.IvParameterSpec;

import java.security.*;
import java.security.spec.RSAPrivateKeySpec;
import java.security.spec.RSAPublicKeySpec;

/**
 * 
 * This is an application to encrypt and sign a file to be sent by email. The
 * sender knows the public key of destination, and has a private key to sign the
 * file. The application can also be used by a receiver to Decrypt the file
 * using his private key and verify the signature using the public key of the
 * sender.
 * 
 * Encryption Process: Sender encrypts a message using Advanced Encryption
 * Standard (AES). The sender uses a destination public RSA key to encrypt an
 * AES key. Finally, the AES key is shared witht he destination using the
 * concepts of asymmetric key cryptography. The AES key is wrapped with the
 * destination public key and (Encrypted AES key, ciphertext) bytes are hashed
 * and signed with the sender's RSA private key. The RSA key pairs are generated
 * using the RSAKeyGen application. Standard 1024 bit RSA keys are used for RSA.
 * 
 * Decryption Process: Destination user reads the encryptedtext file first
 * verifies the signature of the sender. Once the signature is verified, it
 * proceeds to Unwrap the AES key by using its private key. Then it proceeds to
 * decrypt the ciphertext using the AES key.
 * 
 * Parameters: RSA uses the standard 1024 key length, and is generated by the
 * java KeyPairGenerator. New Keys are to be generated with the included
 * RSAKeyGen.java AES uses the default key size with CBC mode of encryption.
 * This is because CBC mode is more secure than ECB. Signature verification is
 * done with SHA1WithRSA. SHA1(AESKey + ciphertext) is used as the signature.
 */

public class fcrypt {

	// Private and Static variables for encryption and decryption
	private static Cipher AESCipher, RSACipher;
	private static Key AESKey;
	private static byte[] ciphertext;
	private static byte[] plaintext;
	private static byte[] InitVector;

	// Private and Static variables for encryption
	private static KeyGenerator AESKeyGen;
	private static PublicKey RSAPublicKey;

	// Private and Static members for decryption
	private static PrivateKey RSAPrivateKey;

	/**
	 * Function: main
	 * 
	 * @param args
	 *            : String[]
	 * 
	 * @return void
	 * 
	 *         Function checks the input array of strings and makes a decision
	 *         to call either the encryption process or decryption process. Also
	 *         performs usage checks on the inputs.
	 */
	public static void main(String[] args) {
		// Usage analysis on the inputs
		if (args.length != 5) {
			// Output correct usage instructions.
			usageInstruction();

			// Error termination of program.
			System.exit(args.length);
		}

		// Encryption or Decryption decision.
		try {
			if (args[0].equals("-e")) {

				// Generate cipher objects needed for encryption (AES) and
				// signing (RSA)
				try {
					AESCipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
					RSACipher = Cipher.getInstance("RSA");
				} catch (GeneralSecurityException e) {
					System.out
							.println("Error in generating ciphers during encryption.");
					e.printStackTrace();
				}

				// Generated AES key for actual file encryption.
				try {
					AESKeyGen = KeyGenerator.getInstance("AES");
				} catch (GeneralSecurityException e) {
					System.out
							.println("Error in generating AES key generation during encryption.");
					e.printStackTrace();
				}
				AESKey = AESKeyGen.generateKey();

				// Function call to encrypt the plaintext file.
				startEncryption(args);
			} else if (args[0].equals("-d")) {

				// Generate cipher objects needed for decryption (AES) and
				// signature verification (RSA)
				try {
					AESCipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
					RSACipher = Cipher.getInstance("RSA");
				} catch (GeneralSecurityException e) {
					System.out
							.println("Error in generating cipher objects during decryption.");
					e.printStackTrace();
				}

				// Function call to decrypt the ciphertext file.
				startDecryption(args);
			} else {
				// Output correct usage instructions.
				usageInstruction();
			}
		} catch (IndexOutOfBoundsException iobe) {
			usageInstruction();
		}

		finally {
			// Normal termination.
			System.exit(0);
		}
	} // End of main

	/**
	 * Function: usageInstruction
	 * 
	 * @param void
	 * 
	 * @return void
	 * 
	 *         Outputs the correct usage instructions to the user
	 */
	private static void usageInstruction() {
		System.out.println("Incorrect Usage .. \n");
		System.out.println("Usage:");
		System.out.println("java fcrypt -e destination_public_key_filename"
				+ " sender_private_key_filename input_plaintext_file"
				+ " output_ciphertext_file\n");
		System.out.println("\n or \n");
		System.out.println("\njava fcrypt -d destination_private_key_filename"
				+ " sender_public_key_filename input_ciphertext_file"
				+ " output_plaintext_file");
	}

	/**
	 * Function: startEncryption
	 * 
	 * @param args
	 *            : String[]. The same arguments to the main function
	 * 
	 * @return void
	 * 
	 *         Performs the encryption process of the plaintext file and dumps
	 *         the encypted data in the cyphertext file provided in the inputs.
	 */
	private static void startEncryption(String[] args) {
		try {
			// Encryption steps.
			RSAPublicKey = getPublicKeyFromFile(new File(args[1]));

			RSAPrivateKey = getPrivateKeyFromFile(new File(args[2]));

			plaintext = getBytesFromFile(new File(args[3]));

			// steps in file encryption.
			ciphertext = AESEncryption(plaintext);

			// Sign the AES key and ciphertext and write to ciphertext file
			RSASigning(args[4]);

			System.out.println("Encryption Successful. Check ciphertext.txt");

		} catch (Exception e) {
			System.out.println("Error in encryption.");

			// Error termination due to exception.
			System.exit(-1);
		}
	} // End of startEncryption

	/**
	 * Function: getBytesFromFile
	 * 
	 * @param plaintextFile
	 *            : File This file contains the plain text to be encrypted.
	 * 
	 * @return byte[]
	 * 
	 * @throws IO
	 *             Exception
	 * 
	 *             convert File to byte[]
	 */
	private static byte[] getBytesFromFile(File plaintextFile)
			throws IOException {
		byte[] plaintextBytes = new byte[(int) plaintextFile.length()];

		try {
			FileInputStream fis = new FileInputStream(plaintextFile);
			fis.read(plaintextBytes);
			fis.close();
		} catch (IOException e) {
			System.out
					.println("Error in reading from plaintext file during encryption.");

			// Error termination.
			System.exit(-1);
		}

		return plaintextBytes;
	} // End of getBytesFromFile.

	/**
	 * Function: AESEncryption
	 * 
	 * @param plaintextBytes
	 *            : byte[]
	 * 
	 * @return ciphertextBytes : byte[]
	 * 
	 * @throws GeneralSecurityException
	 * 
	 *             Encrypt the plaintext bytes to ciphertext bytes using AES
	 *             encrytion.
	 */
	private static byte[] AESEncryption(byte[] plaintextBytes)
			throws GeneralSecurityException {
		// Initialize the cipher for encryption
		AESCipher.init(Cipher.ENCRYPT_MODE, AESKey);

		// get an initialization vector:
		InitVector = AESCipher.getIV();

		// Encrypt the plaintext bytes.
		ciphertext = AESCipher.doFinal(plaintextBytes);

		return ciphertext;
	}

	/**
	 * Function: RSASigning
	 * 
	 * @param cipherTextFile
	 *            : File
	 * 
	 * @return void
	 * 
	 *         This procedure encrypts the AESKey with destination public key
	 *         and signs the encrypted AES key and ciphertext with sender's
	 *         private RSA key. This data is then written to the ciphertext file
	 *         (input).
	 */
	private static void RSASigning(String cipherTextFile) {
		try {
			FileOutputStream fos = new FileOutputStream(cipherTextFile);
			DataOutputStream dos = new DataOutputStream(fos);

			byte[] EncryptedAESKey = RSAWrapAESKey(AESKey);

			Signature sign = Signature.getInstance("SHA1WithRSA");
			sign.initSign(RSAPrivateKey);

			// Update the signature with the RSA encrypted AES key and the
			// cipher-text
			// concatenated to each other.
			sign.update(concatenate(EncryptedAESKey, ciphertext));

			byte[] signBytes = sign.sign();

			dos.writeInt(EncryptedAESKey.length);
			dos.writeInt(InitVector.length);
			dos.writeInt(ciphertext.length);
			dos.writeInt(signBytes.length);
			dos.write(EncryptedAESKey);
			dos.write(InitVector);
			dos.write(ciphertext);
			dos.write(signBytes);
			
			dos.close();
			fos.close();
		} catch (Exception e) {
			System.out.println("Error in RSA signing.");

			// Error Termination.
			System.exit(-1);
		}
	}

	/**
	 * Function: RSAWrapAESKey
	 * 
	 * @param key
	 *            : Key to be wrapped using RSA
	 * 
	 * @return byte[]
	 * 
	 * @throws GeneralSecurityException
	 * 
	 *             Function wraps the AES key with destination public key.
	 */
	private static byte[] RSAWrapAESKey(Key key)
			throws GeneralSecurityException {
		byte[] wrappedKey;

		// Initialize the cipher for wrapping
		RSACipher.init(Cipher.WRAP_MODE, RSAPublicKey);

		// Wrap the key
		wrappedKey = RSACipher.wrap(key);

		return wrappedKey;
	}

	/**
	 * Function: startDecryption
	 * 
	 * @param args
	 *            : String[]. The same arguments to the main function
	 * 
	 * @return void
	 * 
	 * @throws none
	 * 
	 *             Performs the decryption process of the ciphertext file and
	 *             dumps the decrypted data in the plaintext file provided in
	 *             the inputs.
	 */
	private static void startDecryption(String[] args) {
		try {
			RSAPrivateKey = getPrivateKeyFromFile(new File(args[1]));

			RSAPublicKey = getPublicKeyFromFile(new File(args[2]));

			plaintext = fileDecrypt(new File(args[3]));

			writePlaintextToFile(plaintext, new File(args[4]));

		} catch (Exception e) {
			System.out.println("Error in decryption.");

			// Error termination due to exception.
			System.exit(-1);
		}
	} // End of startDecryption.

	/**
	 * Function: fileDecrypt
	 * 
	 * @param ciphertextFile
	 *            : File This file contains the ciphertext that needs to be
	 *            decrypted and whose signature also needs to be verified.
	 * 
	 * @return plaintextBytes : byte[]
	 * 
	 * @throws IOException
	 * 
	 *             This function takes the ciphertext file as an input and
	 *             verifies the signature using sender's private key and then
	 *             unwraps the Encrypted AES key using dest private key. Then
	 *             the encrypted ciphertext is decrypted using the original
	 *             AESKey.
	 */
	private static byte[] fileDecrypt(File ciphertextFile) throws IOException {
		byte[] EncryptedAESKey, signBytes;
		byte[] plaintextData = new byte[0];

		try {
			FileInputStream fis = new FileInputStream(ciphertextFile);
			DataInputStream dis = new DataInputStream(fis);

			// Initialization of array for Encrypted AES key.
			EncryptedAESKey = new byte[dis.readInt()];

			// Initialization of array for Initialization Vector.
			InitVector = new byte[dis.readInt()];

			// Initialization of the array for ciphertext bytes
			ciphertext = new byte[dis.readInt()];

			// Initialization of the array for signature bytes
			signBytes = new byte[dis.readInt()];

			// Read the corresponding data.
			dis.read(EncryptedAESKey);
			dis.read(InitVector);
			dis.read(ciphertext);
			dis.read(signBytes);

			// To verify the signature, the destination generates the signature
			// in the
			// same way the sender did and compare the 2 signatures.
			Signature sign = Signature.getInstance("SHA1WithRSA");
			sign.initVerify(RSAPublicKey);

			// Update the signature with the RSA encrypted AES key and the
			// ciphertext
			// concatenated to each other.
			sign.update(concatenate(EncryptedAESKey, ciphertext));

			// Verification
			if (sign.verify(signBytes)) {
				// Signature is valid
				System.out.println("Valid Signature !!!\n");

				AESKey = RSAUnwrapEncryptedAESKey(EncryptedAESKey);

				plaintextData = AESDecryption(ciphertext);

				System.out
						.println("Decryption successful. Check plaintext.txt\n");
			} else {
				System.out.println("Invalid Signature !!!");

				// Error termination of program.
				System.exit(-1);
			}
			
			dis.close();
			fis.close();
		} catch (Exception e) {
			e.printStackTrace();

			// Error termination.
			System.exit(-1);
		} // End of try

		return plaintextData;
	}

	/**
	 * Function: AESDecryption
	 * 
	 * @param ciphertextBytes
	 *            : byte[]
	 * 
	 * @return plaintextBytes : byte[]
	 * 
	 * @throws GeneralSecurityException
	 * 
	 *             Function decrypts the ciphertext using the RSA to return the
	 *             original plaintext,
	 */
	private static byte[] AESDecryption(byte[] ciphertextBytes)
			throws GeneralSecurityException {
		byte[] plaintextBytes;
		// Initialize the cipher with the AES key and Initialization Vector for
		// decryption
		AESCipher.init(Cipher.DECRYPT_MODE, AESKey, new IvParameterSpec(
				InitVector));

		// Get the decrypted plaintext
		plaintextBytes = AESCipher.doFinal(ciphertextBytes);

		return plaintextBytes;
	}

	/**
	 * Function: RSAUnwrapEncryptedAESKey
	 * 
	 * @param key
	 *            : Key to be Unwrapped using RSA
	 * 
	 * @return Key : Unwrapped AES Key
	 * 
	 * @throws GeneralSecurityException
	 * 
	 *             Function unwraps the wrapped AES key with destination private
	 *             key.
	 */
	private static Key RSAUnwrapEncryptedAESKey(byte[] keyBytes)
			throws GeneralSecurityException {
		Key unwrappedKey;
		// Initialize the cipher for Unwrapping
		RSACipher.init(Cipher.UNWRAP_MODE, RSAPrivateKey);

		// Unwrap the key bytes
		unwrappedKey = RSACipher.unwrap(keyBytes, "AES", Cipher.SECRET_KEY);

		return unwrappedKey;
	}

	/**
	 * Function: writePlaintextToFile
	 * 
	 * @param paintextData
	 *            : byte[] plaintextFile : File
	 * 
	 * @return void
	 * 
	 * @throws IOException
	 * 
	 *             Writes the plaintext data into the plaintext file
	 */

	private static void writePlaintextToFile(byte[] paintextData,
			File plaintextFile) throws IOException {
		FileOutputStream fos = new FileOutputStream(plaintextFile);
		DataOutputStream dos = new DataOutputStream(fos);

		try {
			dos.write(paintextData);
		} catch (IOException e) {
			System.out.println("IO Error in writing to plaintext file.");
			System.exit(-1);
		}

		finally {
			dos.close();
		}
	}

	/**
	 * Function: getPublicKeyFromFile
	 * 
	 * @param publicKeyFile
	 *            : File This file contains the public key from the
	 *            KeyPairGenerator.
	 * 
	 * @return PublicKey
	 * 
	 * @throws IOException
	 * 
	 *             Reads the RSA public key from the specified input file.
	 */
	private static PublicKey getPublicKeyFromFile(File publicKeyFile)
			throws IOException {
		FileInputStream fis = new FileInputStream(publicKeyFile);
		ObjectInputStream oin = new ObjectInputStream(fis);
		PublicKey pubKey;

		try {
			// read the modulus & exponent values from the file.
			BigInteger modulus = (BigInteger) oin.readObject();
			BigInteger exponent = (BigInteger) oin.readObject();

			// Generate the public key from the mod & exp parts from the file.
			RSAPublicKeySpec keySpec = new RSAPublicKeySpec(modulus, exponent);
			KeyFactory fact = KeyFactory.getInstance("RSA");
			pubKey = fact.generatePublic(keySpec);

			return pubKey;
		} catch (Exception e) {
			throw new RuntimeException("Spurious serialisation error", e);
		}

		// Close file input stream.
		finally {
			oin.close();
		}
	} // End of getPublicKeyFromFile.

	/**
	 * Function: getPrivateKeyFromFile
	 * 
	 * @param privateKeyFile
	 *            : File. This file contains the private key from the
	 *            KeyPairGenerator.
	 * 
	 * @return PrivateKey
	 * 
	 * @throws IOException
	 * 
	 *             Reads the RSA private key from the specified input file.
	 */
	private static PrivateKey getPrivateKeyFromFile(File privateKeyFile)
			throws IOException {
		FileInputStream fis = new FileInputStream(privateKeyFile);
		ObjectInputStream oin = new ObjectInputStream(fis);
		PrivateKey privateKey;

		try {
			// read the modulus & exponent values from the file.
			BigInteger modulus = (BigInteger) oin.readObject();
			BigInteger exponent = (BigInteger) oin.readObject();

			// Generate the private key from the mod & exp parts from the file.
			RSAPrivateKeySpec keySpec = new RSAPrivateKeySpec(modulus, exponent);
			KeyFactory fact = KeyFactory.getInstance("RSA");
			privateKey = fact.generatePrivate(keySpec);

			return privateKey;
		} catch (Exception e) {
			throw new RuntimeException("Spurious serialisation error", e);
		}

		// Close file input stream.
		finally {
			oin.close();
		}
	} // End of getPrivateKeyFromFile.

	/**
	 * Function: concatenate
	 * 
	 * @param array1
	 *            : byte[]
	 * @param array2
	 *            : byte[]
	 * 
	 * @return byte[] : concatenated byte[] of array1 and array2
	 * 
	 * @throws none
	 * 
	 *             Function concatenates the Encrypted AES key and the
	 *             ciphertext bytes.
	 */
	private static byte[] concatenate(byte[] array1, byte[] array2) {
		int arr1Len = array1.length;
		int arr2Len = array2.length;
		byte[] concatResult;

		if (0 == arr1Len) {
			concatResult = array2;
		} else if (0 == arr2Len) {
			concatResult = array1;
		} else {
			concatResult = (byte[]) java.lang.reflect.Array.newInstance(array1
					.getClass().getComponentType(), arr1Len + arr2Len);
			System.arraycopy(array1, 0, concatResult, 0, arr1Len);
			System.arraycopy(array2, 0, concatResult, arr1Len, arr2Len);
		}

		return concatResult;
	} // end of concatenate

}
